[{"title":"深搜练习2","date":"2019-11-18T14:21:20.000Z","path":"2019/11/18/深搜练习2/","text":"3095: 玉树搜救行动 时间限制(普通/Java):1000MS/3000MS 内存限制:65536KByte 总提交: 1990 测试通过:983 描述 自从玉树受灾以来，有关部门一直在现场抢救落难的人。他们用个种方法搜救，用上了搜救犬，有了搜救犬找到生命迹象就容易了。 假设现场用一个矩阵表示，抢救的有多条搜救犬，受灾的人也有多个可能。 例子: #p.d#p# #####.# d……..# ######p d表示搜救狗，p表示受灾的人，点表示可以通行的路，#表示石头挡住的路，不能通行。 搜救狗只能上下左右走，不能越过障碍物。 上面的那个例子最多可以救到2个人。因为第三个人被四周包围搜救狗无法到达。 输入 输入数据有多组。每组两个整数R，C, 2=&lt;R,C&lt;=100， R表示矩阵的行数，C表示矩阵的列数，然后输入相应矩阵，矩阵保证有搜救狗和受灾的人。当输入R=0且C=0时候输入结束。 输出 输出搜救狗最多能救多少受灾的人的数量。 样例输入 4 7 #p.d#p# #####.# d…..# ######p 0 0 样例输出 2 思路： 图上记下’d’,’p’的坐标，对’d’进行深搜，走过的为不能走，找到一个人++，直到深搜结束。对每一个’d’都深搜，最后输出总救出人数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;using namespace std;int n,m,c,a1,a2,f,s;char gra[105][105];bool vis[105][105];int dx[10005],dy[10005],px[10005],py[10005];int x[]=&#123;1,-1,0,0&#125;;int y[]=&#123;0,0,1,-1&#125;;void dfs(int xx,int yy)&#123; for(int i=0;i&lt;a2;i++) &#123; if(xx==px[i] &amp;&amp; yy==py[i] ) //如果找到++ &#123; f++; &#125; &#125; for(int i=0;i&lt;4;i++) &#123; int sx=xx+x[i]; int sy=yy+y[i]; if(sx&lt;n &amp;&amp; sx&gt;=0 &amp;&amp; sy&lt;m &amp;&amp; sy&gt;=0 &amp;&amp; !vis[sx][sy]&amp;&amp; gra[sx][sy]!='#') //在图内且能走 &#123; vis[sx][sy]=1; //图上修改为不能走 ///printf(\"%d %d\\n\",dx,dy); dfs(sx,sy); //递归 &#125; &#125;&#125;void init() //初始化&#123; memset(vis,0,sizeof(vis)); memset(dx,0,sizeof(dx)); memset(dy,0,sizeof(dy)); memset(px,0,sizeof(px)); memset(py,0,sizeof(py));&#125;int main()&#123; while(scanf(\"%d%d\",&amp;n,&amp;m),n || m) &#123; a1=0,a2=0;s=0; init(); for(int i=0;i&lt;n;i++) &#123; getchar(); for(int j=0;j&lt;m;j++) &#123; gra[i][j]=getchar(); if(gra[i][j]=='d') &#123; dx[a1]=i; dy[a1++]=j; &#125; else if(gra[i][j]=='p') &#123; px[a2]=i; py[a2++]=j; &#125; &#125; &#125; for(int i=0;i&lt;a1;i++) //遍历'd'坐标 &#123; f=0; dfs(dx[i],dy[i]); s+=f; &#125; printf(\"%d\\n\",s); &#125; return 0;&#125;","categories":[],"tags":[{"name":"深搜","slug":"深搜","permalink":"http://yoursite.com/tags/%E6%B7%B1%E6%90%9C/"}]},{"title":"深搜练习1","date":"2019-11-18T13:59:09.000Z","path":"2019/11/18/深搜练习1/","text":"2816: 勘探油田 时间限制(普通/Java):1000MS/3000MS 内存限制:65536KByte 总提交: 1405 测试通过:842 描述 某石油勘探公司正在按计划勘探地下油田资源。他们工作在一片长方形的地域中，首先将该地域划分为许多小正方形区域，然后使用探测设备分别探测每一块小正方形区域是否有油。若在一块小正方形区域中探测到有油，则标记为’@’，否则标记为’*’。如果两个相邻区域都为1，那么它们同属于一个石油带，一个石油带可能包含很多小正方形区域，而你的任务是要确定在一片长方形地域中有多少个石油带。所谓相邻，是指两个小正方形区域上下、左右、左上右下或左下右上同为’@’。 输入 每个长方形地域，输出油带的个数，每个油带值占独立的一行。油带值不会超过100。 样例输入 3 5*@*@***@***@*@*0 0 样例输出 1 思路： 在地图上先记下‘@’的坐标，遍历‘@’坐标，进行深搜，在每次深搜前，先判断坐标地图上是否为‘@’,每次深搜油带+1。深搜可以走八个方向，每次将搜到的油田为’*’ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;using namespace std;int n,m,c,a1,f,s;char gra[105][105]; //地图int dx[105],dy[105]; //油田的坐标int x[]=&#123;1,-1,0,0,1,-1,-1,1&#125;;int y[]=&#123;0,0,1,-1,1,-1,1,-1&#125;;void dfs(int xx,int yy)&#123; if(gra[xx][yy]=='@') //如果找到标记为'*' &#123; gra[xx][yy]='*'; &#125; for(int i=0;i&lt;8;i++) //8个方向 &#123; int sx=xx+x[i]; int sy=yy+y[i]; if(sx&lt;n &amp;&amp; sx&gt;=0 &amp;&amp; sy&lt;m &amp;&amp; sy&gt;=0 &amp;&amp; gra[sx][sy]!='*') //在图内且能走 &#123; gra[sx][sy]='*'; //图上修改为不能走 dfs(sx,sy); //递归 &#125; &#125;&#125;void init()&#123; memset(dx,0,sizeof(dx)); memset(dy,0,sizeof(dy));&#125;int main()&#123; while(scanf(\"%d%d\",&amp;n,&amp;m),n ) &#123; a1=0;s=0; init(); for(int i=0;i&lt;n;i++) &#123; getchar(); for(int j=0;j&lt;m;j++) &#123; gra[i][j]=getchar(); if(gra[i][j]=='@') &#123; dx[a1]=i; dy[a1++]=j; &#125; &#125; &#125; for(int i=0;i&lt;a1;i++) &#123; if(gra[dx[i]][dy[i]]=='@') &#123; s++; dfs(dx[i],dy[i]); &#125; &#125; printf(\"%d\\n\",s); &#125; return 0;&#125;","categories":[],"tags":[{"name":"深搜","slug":"深搜","permalink":"http://yoursite.com/tags/%E6%B7%B1%E6%90%9C/"}]},{"title":"广搜","date":"2019-11-17T07:33:39.000Z","path":"2019/11/17/广搜（BFS）/","text":"广度优先搜索Breadth First Search，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。 是一种用于图的查找算法，可帮助回答两类问题: 第一类问题: 从节点A出发，前往节点B的路径 第二类问题: 从节点A出发，前往节点B的哪条路径最短 1005: Hero In Maze时间限制(普通/Java):1000MS/10000MS 内存限制:65536KByte 总提交: 5700 测试通过:1360 500年前，Jesse是我国最卓越的剑客。他英俊潇洒，而且机智过人^_^。突然有一天，Jesse心爱的公主被魔王困在了一个巨大的迷宫中。Jesse听说这个消息已经是两天以后了，他知道公主在迷宫中还能坚持T天，他急忙赶到迷宫，开始到处寻找公主的下落。时间一点一点的过去，Jesse还是无法找到公主。最后当他找到公主的时候，美丽的公主已经死了。从此Jesse郁郁寡欢，茶饭不思，一年后追随公主而去了。T_T500年后的今天，Jesse托梦给你，希望你帮他判断一下当年他是否有机会在给定的时间内找到公主。他会为你提供迷宫的地图以及所剩的时间T。请你判断他是否能救出心爱的公主。 输入 题目包括多组测试数据。每组测试数据以三个整数N,M,T(0&lt;n, m&lt;=20, t&gt;0)开头，分别代表迷宫的长和高，以及公主能坚持的天数。紧接着有M行，N列字符，由”.”，”*”，”P”，”S”组成。其中“.” 代表能够行走的空地。“*” 代表墙壁，Jesse不能从此通过。“P” 是公主所在的位置。“S” 是Jesse的起始位置。每个时间段里Jesse只能选择上、下、左、右任意一方向走一步。输入以0 0 0结束。 输出 如果能在规定时间内救出公主输出YES，否则输出NO。 样例输入 4 4 10….….….S**P0 0 0 样例输出 YES 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;bits/stdc++.h&gt;#include &lt;algorithm&gt;using namespace std;char gra[25][25]; //地图bool vis[25][25]=&#123;0&#125;; //判断点是否走过int dir[4][2]=&#123;-1,0,0,-1,1,0,0,1&#125;; //走的方向int m,n,t,step;int sy,sx;struct point&#123; int x,y,s; //坐标，步长&#125;;bool BFS()&#123; queue&lt;point&gt; qu; vis[sx][sy]=1; qu.push(&#123;sx,sy,0&#125;); //队列初始化 while(!qu.empty()) &#123; int y=qu.front().y,x=qu.front().x,s=qu.front().s; //返回队列的第一个元素 if(gra[x][y]=='P') &#123; return s&lt;=step; &#125; for(int i=0;i&lt;4;i++) &#123; sy=y+dir[i][0]; sx=x+dir[i][1]; if(sx&lt;n &amp;&amp; sx&gt;=0 &amp;&amp; sy&lt;m &amp;&amp; sy&gt;=0 &amp;&amp; !vis[sx][sy] &amp;&amp; gra[sx][sy]!='*') //在图内，未走过,且不为'*' &#123; vis[sx][sy]=1; qu.push(&#123;sx,sy,s+1&#125;); //入队，并且步长+1 //printf(\"%d %d %d\\n\",sx,sy,s); &#125; &#125; qu.pop(); //出队 &#125; return 0;&#125;int main()&#123; while(scanf(\"%d%d%d\",&amp;m,&amp;n,&amp;step),m || n || step) &#123; memset(vis,0,sizeof(vis)); //初始化vis for(int i=0;i&lt;n;i++) &#123; getchar(); for(int j=0;j&lt;m;j++) &#123; gra[i][j]=getchar(); if(gra[i][j]=='S')sx=i,sy=j; &#125; &#125; bool f=BFS(); printf(\"%s\\n\",f? \"YES\" : \"NO\"); &#125; return 0;&#125;","categories":[],"tags":[{"name":"广搜","slug":"广搜","permalink":"http://yoursite.com/tags/%E5%B9%BF%E6%90%9C/"}]},{"title":"深搜","date":"2019-11-17T07:33:39.000Z","path":"2019/11/17/深度优先搜索（DFS）/","text":"深度优先搜索（DFS）属于图算法的一种，英文缩写为DFS即Depth First Search. 其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次； 深度优先遍历图的思想是，从图中某顶点v出发： （1）访问顶点v； （2）依次从v的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和v有路径相通的顶点都被访问； （3）若此时图中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到图中所有顶点均被访问过为止。 深搜通过向下深入，向上回溯的方式搜索，类似栈它的空间效率高，然则找到的不必定是最优解，所以一些深搜需要高效的剪枝（优化） 深搜是通过函数的递归实现，所以递归次数过多，可能造成爆栈和超时，一般通过用栈模拟深搜过程防止爆栈，通过剪枝的方式防止超时。 2777: Hero in Maze 简单版时间限制(普通/Java):1000MS/3000MS 内存限制:65536KByte 总提交: 2145 测试通过:785 500年前，Jesse是我国最卓越的剑客。他英俊潇洒，而且机智过人^_^。突然有一天，Jesse心爱的公主被魔王困在了一个巨大的迷宫中。Jesse听说这个消息已经是两天以后了，他急忙赶到迷宫，开始到处寻找公主的下落。请你判断他是否能救出心爱的公主。(假设有路可以通到公主那就可以找到公主)。 输入 题目包括多组测试数据。每组测试数据以两个整数n,m(0&lt;n, m≤20)开头，分别代表迷宫的长和高。紧接着有m行，n列字符，由”.”，”*”，”P”，”S”组成。其中“.” 代表能够行走的空地。“*” 代表墙壁，Jesse不能从此通过。“P” 是公主所在的位置。“S” 是Jesse的起始位置。Jesse只能选择上、下、左、右任意一方向走一步。输入以0 0结束。 输出 如果能救出公主输出YES，否则输出NO。 样例输入 4 4 ….….….S**P4 4….…. **** S**P 0 0 样例输出 YES NO 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;using namespace std;char q[25][25];int sx,sy,px,py; int f,n,m;;int x[]=&#123;1,-1,0,0&#125;;int y[]=&#123;0,0,1,-1&#125;;void dfs(int xx,int yy)&#123; if(xx==px &amp;&amp; yy==py ) //如果找到返回 &#123; f=1; return; &#125; for(int i=0;i&lt;4;i++) &#123; int dx=xx+x[i]; int dy=yy+y[i]; if(dx&lt;n &amp;&amp; dx&gt;=0 &amp;&amp; dy&lt;m &amp;&amp; dy&gt;=0 &amp;&amp; q[dx][dy]!='*') //在图内且能走 &#123; q[dx][dy]='*'; //图上修改为不能走 ///printf(\"%d %d\\n\",dx,dy); dfs(dx,dy); //递归 &#125; &#125;&#125;int main()&#123; while(scanf(\"%d%d\",&amp;n,&amp;m),n||m) &#123; f=0; for(int i =0;i&lt;n;i++) &#123; getchar(); for(int j=0;j&lt;m;j++) &#123; q[i][j]=getchar(); if(q[i][j]=='S')sx=i,sy=j; else if(q[i][j]=='P')px=i,py=j; &#125; &#125; dfs(sx,sy); printf(\"%s\\n\",(f? \"YES\":\"NO\")); &#125; return 0;&#125;","categories":[],"tags":[{"name":"深搜","slug":"深搜","permalink":"http://yoursite.com/tags/%E6%B7%B1%E6%90%9C/"}]}]